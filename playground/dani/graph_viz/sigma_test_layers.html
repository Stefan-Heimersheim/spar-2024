<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sigma.js Graph Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.1/graphology.umd.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    #sigma-container {
      width: 75%;
      height: 100%;
    }
    #info-panel {
      width: 25%;
      height: 100%;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      background-color: #f0f0f0;
    }
    #feature-info {
      flex-grow: 1;
      overflow-y: auto;
    }
    #settings {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sigma-container"></div>
    <div id="info-panel">
      <div id="feature-info">
        <h2>Feature Information</h2>
        <p>Hover over a node to see information</p>
      </div>
      <div id="settings">
        <h3>Settings</h3>
        <h4>Layer Sort:</h4>
        <label>
          <input type="radio" name="layer-sort" value="feature-index" checked> Feature Index
        </label>
        <br>
        <label>
          <input type="radio" name="layer-sort" value="minimize-crossings"> Minimize Crossings
        </label>
      </div>
    </div>
  </div>
  <script>
    let sigmaInstance;
    let graph;

    function updateLayout() {
      const sortMethod = document.querySelector('input[name="layer-sort"]:checked').value;
      const containerWidth = document.getElementById('sigma-container').offsetWidth;
      const containerHeight = document.getElementById('sigma-container').offsetHeight;

      // Group nodes by layer
      const nodesByLayer = {};
      graph.forEachNode((node, attributes) => {
        if (!nodesByLayer[attributes.layer]) {
          nodesByLayer[attributes.layer] = [];
        }
        nodesByLayer[attributes.layer].push({ id: node, attributes });
      });

      if (sortMethod === 'minimize-crossings') {
        // Sort nodes within each layer to minimize edge crossings
        Object.keys(nodesByLayer).forEach(layer => {
          nodesByLayer[layer].sort((a, b) => {
            const aConnections = graph.degree(a.id);
            const bConnections = graph.degree(b.id);
            return bConnections - aConnections;
          });
        });
      } else {
        // Sort nodes by their numerical index within each layer
        Object.keys(nodesByLayer).forEach(layer => {
          nodesByLayer[layer].sort((a, b) => {
            const aIndex = parseInt(a.id.split('_')[1]);
            const bIndex = parseInt(b.id.split('_')[1]);
            return aIndex - bIndex;
          });
        });
      }

      // Assign positions to nodes
      const layerCount = Object.keys(nodesByLayer).length;
      const topMargin = 120;
      const bottomMargin = 40;
      const layerSpacing = (containerHeight - topMargin - bottomMargin) / (layerCount - 1);
      const horizontalPadding = containerWidth * 0.05;

      Object.keys(nodesByLayer).forEach((layer, layerIndex) => {
        const nodesInLayer = nodesByLayer[layer].length;
        const availableWidth = containerWidth - 2 * horizontalPadding;
        const nodeSpacing = availableWidth / (nodesInLayer - 1 || 1);
        nodesByLayer[layer].forEach((node, index) => {
          graph.setNodeAttribute(node.id, 'x', horizontalPadding + index * nodeSpacing);
          graph.setNodeAttribute(node.id, 'y', topMargin + layerIndex * layerSpacing);
        });
      });

      if (sigmaInstance) {
        sigmaInstance.refresh();
      }
    }

    function updateInfoPanel(nodeId) {
      const node = graph.getNodeAttributes(nodeId);
      const layer = node.layer;
      const featureNumber = nodeId.split('_')[1];
      
      let html = `<h3>Layer ${layer} Feature ${featureNumber}</h3>`;
      html += `<p>Description placeholder</p>`;
      
      // Parent features
      html += `<h4>Parent features:</h4>`;
      graph.forEachInEdge(nodeId, (edge, attributes, source, target, sourceAttributes, targetAttributes) => {
        const parentLayer = graph.getNodeAttributes(source).layer;
        const parentFeatureNumber = source.split('_')[1];
        html += `<p>Layer ${parentLayer} Feature ${parentFeatureNumber}: Description placeholder. `;
        html += `Similarity: ${attributes.label}</p>`;
      });
      
      // Child features
      html += `<h4>Child features:</h4>`;
      graph.forEachOutEdge(nodeId, (edge, attributes, source, target, sourceAttributes, targetAttributes) => {
        const childLayer = graph.getNodeAttributes(target).layer;
        const childFeatureNumber = target.split('_')[1];
        html += `<p>Layer ${childLayer} Feature ${childFeatureNumber}: Description placeholder. `;
        html += `Similarity: ${attributes.label}</p>`;
      });
      
      document.getElementById('feature-info').innerHTML = html;
    }

    fetch('sample_graph.json')
      .then(response => response.json())
      .then(data => {
        graph = new graphology.Graph({multi: true});

        // Add nodes with initial positions
        const containerWidth = document.getElementById('sigma-container').offsetWidth;
        const containerHeight = document.getElementById('sigma-container').offsetHeight;
        const layerCount = Math.max(...data.nodes.map(node => node.layer)) + 1;
        const layerSpacing = containerHeight / (layerCount - 1);

        data.nodes.forEach((node, index) => {
          graph.addNode(node.id, {
            x: Math.random() * containerWidth, // Random initial x position
            y: node.layer * layerSpacing, // Y position based on layer
            size: 5,
            label: node.id,
            layer: node.layer,
            originalIndex: index
          });
        });

        // Add edges
        data.links.forEach((link, i) => {
          graph.addEdge(link.source, link.target, {
            id: `e${i}`,
            size: 4*link.similarity,
            label: `${link.measure}: ${link.similarity.toFixed(2)}`,
          });
        });

        const container = document.getElementById('sigma-container');
        
        try {
          sigmaInstance = new Sigma(graph, container, {
            renderEdgeLabels: false,
            allowWheelZoom: false,
          });

          updateLayout();

          // Hover effects
          sigmaInstance.on('enterNode', (event) => {
            updateInfoPanel(event.node);
          });

          sigmaInstance.on('leaveNode', () => {
            document.getElementById('feature-info').innerHTML = '<h2>Feature Information</h2><p>Hover over a node to see information</p>';
          });

          // Add event listener for layout change
          document.querySelectorAll('input[name="layer-sort"]').forEach(radio => {
            radio.addEventListener('change', updateLayout);
          });

        } catch (error) {
          console.error('Error creating renderer:', error);
        }
      })
      .catch(error => console.error('Error:', error));

    // Add window resize event listener
    window.addEventListener('resize', updateLayout);
  </script>
</body>
</html>